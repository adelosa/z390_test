*********************************************************************
* Copyright 2006 Automated Software Tools Corporation               *
* This source code is part of z390 assembler/emulator package       *
* The z390 package is distributed under GNU general public license  *
* Author - Don Higgins                                              *
* Date   - 07/20/07                                                 *
*********************************************************************
* 07/20/07 RPI 374 - add CVTTOHEX for use in TESTFPC1 
*********************************************************************
*
*  CALL CVTTOHEX,(IN,OUT,INLEN)
*
*    IN    - ADDR INPUT BYTES
*    OUT   - ADDR OUTPUT HEX EBCDIC BYTES
*    INLEN - COUNT OF BYTES TO CONVERT
*********************************************************************
         COPY  ASMMSP       STRUCTURED PROGRAM MACROS AND EQUS
CVTTOHEX SUBENTRY
         LM    R3,R5,0(R1)  R3=IN, R4=OUT, R5=LEN
         DO    WHILE=(LTR,R5,P,R5)
               UNPK WORK(9),0(5,R3)
               TR   WORK(8),TRTHEX
               IF   (CH,R5,GE,=H'4')
                    MVC  0(8,R4),WORK
                    AHI  R4,8
                    AHI  R3,4
                    AHI  R5,-4
               ELSE
                    AR   R5,R5
                    BCTR R5,0
                    MVC  0(0,R4),WORK
                    SR   R5,R5
               ENDIF
         ENDDO
         SUBEXIT
         LTORG
         EQUREGS
WORK     DC    CL9
TRTHEX   DC    240X'00',C'0123456789ABCDEF'
         END
                  


         STC   R3,TYPE
         IF    (CLI,TYPE,GT,7)
               BAS   R12,CFD_RTNS
         ELSE
               BAS   R12,CTD_RTNS
         ENDIF
         SUBEXIT
*********************************************************************
* Level 1 support routines using R12
*********************************************************************
*
* CONVERT FROM DECIMAL R4=A(OUT), R5=A(IN) 
*
CFD_RTNS EQU   *
         LA    R15,0
         IF     (CLI,TYPE,EQ,21) CFD INT128 FROM D40
               BAS   R11,CFD_GET_INT128
         ELSEIF (CLI,TYPE,EQ,22) CFD EH     FROM D40
               MVI   FpconValueLen,FpconValueLenE
               BAS   R11,CFD_CALL
               LE    F0,FpconValueE  F0 =  EB
               THDER F1,R0           F1 =  DH
               LEDR  F2,F1           F2 =  EH
               STE   F2,0(R4)        STORE EH
         ELSEIF (CLI,TYPE,EQ,23) CFD DH     FROM D40
               MVI   FpconValueLen,FpconValueLenD
               BAS   R11,CFD_CALL
               LE    F0,FpconValueD  F0 =  DB
               THDR  F1,R0           F1 =  DH
               STD   F1,0(R4)        STORE DH
         ELSEIF (CLI,TYPE,EQ,24) CFD LH     FROM D40
               MVI   FpconValueLen,FpconValueLenL
               BAS  R11,CFD_CALL
               LD    F0,FpconValueL    F0 =  LB1
               LD    F2,FpconValueL+8  F2 =  LB2
               THDR  F1,F0             F1 =  LH1
               THDR  F3,F2             F3 =  LH2
               STD   F1,0(R4)        STORE   LB1
               STD   F3,8(R4)        STORE   LB2
         ELSEIF (CLI,TYPE,EQ,25) CFD EB     FROM D40
               MVI   FpconValueLen,FpconValueLenE
               BAS   R11,CFD_CALL
               LE    F0,FpconValueE  F0 =  EB
               STE   F0,0(R4)        STORE EB
         ELSEIF (CLI,TYPE,EQ,26) CFD DB     FROM D40
               MVI   FpconValueLen,FpconValueLenD
               BAS   R11,CFD_CALL
               LD    F0,FpconValueD  F0 =  DB
               STD   F0,0(R4)        STORE DB
         ELSEIF (CLI,TYPE,EQ,27) CFD LB     FROM D40
               MVI   FpconValueLen,FpconValueLenL
               BAS   R11,CFD_CALL
               LD    F0,FpconValueL    F0 =  LB1
               LD    F2,FpconValueL+8  F2 =  LB2
               STD   F0,0(R4)        STORE   LB1
               STD   F2,8(R4)        STORE   LB2
         ELSE
               LA   R15,12
         ENDIF
         BR    R12
*
* CONVERT TO DECIMAL
*
CTD_RTNS EQU   *
         LA    R15,0
         IF     (CLI,TYPE,EQ,1) CFD INT128 TO   D40
               BAL   R11,CTD_PUT_INT128
         ELSEIF (CLI,TYPE,EQ,2) CFD EH     TO   D40
               MVI   FpconValueLen,FpconValueLenE
               LE    F0,0(R5)        F0 =  EH
               LDER  F1,F0           R1 =  DH
               TBEDR F2,0,R1         F1 =  EB
               STE   F2,FpconValueE store  EB
               BAS  R11,CTD_CALL
         ELSEIF (CLI,TYPE,EQ,3) CFD DH     TO   D40
               MVI   FpconValueLen,FpconValueLenD
               LD    F0,0(R5)        F0 =  DH
               TBDR  F1,0,R0         F1 =  DB
               STD   F1,FpconValueD store  DB
               BAS  R11,CTD_CALL
         ELSEIF (CLI,TYPE,EQ,4) CFD LH     TO   D40
               MVI   FpconValueLen,FpconValueLenL
               LD    F0,0(R5)        F0 =  LH1
               LD    F2,8(R5)        F2 =  LH2
               TBDR  F1,0,R0         F1 =  LB1
               TBDR  F3,0,R2         F3 =  LB2
               STD   F1,FpconValueD   store  LB1
               STD   F3,FpconValueD+8 store  LB2
               BAS  R11,CTD_CALL
         ELSEIF (CLI,TYPE,EQ,5) CFD EB     TO   D40
               MVI   FpconValueLen,FpconValueLenE
               LE    F0,0(R5)        F0 =  EB
               STE   F0,FpconValueE store  EB
               BAS  R11,CTD_CALL
         ELSEIF (CLI,TYPE,EQ,6) CFD DB     TO   D40
               MVI   FpconValueLen,FpconValueLenD
               LD    F0,0(R5)        F0 =  DB
               STD   F0,FpconValueD store  DB
               BAS  R11,CTD_CALL
         ELSEIF (CLI,TYPE,EQ,7) CFD LB     TO   D40
               MVI   FpconValueLen,FpconValueLenL
               LD    F0,0(R5)        F0 =  LB1
               LD    F2,8(R5)        F2 =  LB2
               STD   F0,FpconValueD   store  LB1
               STD   F2,FpconValueD+8 store  LB2
               BAS  R11,CTD_CALL
         ELSE
               LA   R15,12
               BR   R12
         ENDIF
         BR    R12
*********************************************************************
* Level 2 support routines using R11
*********************************************************************
*
* CFD GET 128 BIT INTEGER FROM DECIMAL 
*
CFD_GET_INT128 EQU *
         MVI   SIGN,C'+'
         IF    (TRT,0(40,R5),NZ,TRTTAB_MINUS)
               MVI SIGN,C'-'
         ENDIF
         IF    (TRT,0(40,R5),NZ,TRTTAB_DIGITS)
               LR  R7,R1   R7 = ADDR FIRST DIGIT
               LA  R1,40(R5)
               SR  R1,R7
               BCTR R1,0
               IF  (EX,R1,EQ,TRTSP)
                   LA   R2,40(R5)
               ENDIF
               SR   R1,R7  
               LR   R2,R1           R2 = #DIGITS
               IF   (CHI,R2,GT,13)
                    AHI   R2,-13
                    LA    R1,0(R2,R7)
                    PACK  PWORK,0(13,R1)
                    SGR   R8,R8
                    CVBG  R9,PWORK  R8-R9 = LAST 13 DIGITS
                    IF    (CHI,R2,GT,13)
                          AHI   R2,-13
                          LA    R1,0(R2,R7)
                          PACK  PWORK,0(13,R1)
                          CVBG  R1,PWORK
                          MLG   R0,=FL8'1E13' 
                          ALGR  R9,R1
                          ALCGR R8,R0 R8-R9 = LAST 26 DIGITS
                          BCTR  R2,0
                          EX    R2,PACK
                          CVBG  R1,PWORK  R1  = FIRST 13 DIGITS
                          MLG   R0,=FL8'1E13' R0:R1 X 10**13
                          LA    R10,13
                          DO    WHILE=(LTR,R10,P,R10)
                                ALGR  R1,R1
                                ALCGR R0,R0   2N
                                LGR   R2,R0
                                LGR   R3,R1   R2:R3 = 2M
                                ALGR  R1,R1
                                ALCGR R0,R0   4N
                                ALGR  R1,R1
                                ALCGR R0,R0   8N
                                ALGR  R1,R3
                                ALCGR R0,R2   10N
                                BCTR  R10,0
                          ENDDO   
                          ALG   R9,R1
                          ALCGR R8,R0     R8:R9 27-39 DIGIT INT128
                    ELSE
                          BCTR  R2,0
                          EX    R2,PACK     
                          PACK  PWORK,0(13,R1)
                          CVBG  R1,PWORK
                          MLG   R0,=FL8'1E13' 
                          ALGR  R9,R1
                          ALCGR R8,R0 R8-R9 = 14-26 DIGIT INT128
                    ENDIF
               ELSE
                    BCTR  R2,0
                    EX    R2,PACK     
                    PACK  PWORK,0(13,R1)
                    SGR   R8,R8
                    CVBG  R9,PWORK     R8:R9 = 1-13 DIGIT INT128
               ENDIF
               STG   R8,0(R5)
               STG   R9,8(R5)
         ELSE
               LA   R15,12      NO DIGITS FOUND
               BR   R11
         ENDIF
         LA    R15,0
         BR    R11
PACK     PACK  PWORK,0(0,R7)   PACK FIRST 13 OR LESS
TRTSP    TRT   0(0,R7),TRTTAB_SPACE
*
* CTD PUT INT128
*
CTD_PUT_INT128 EQU *
         MVC   AFIRST,=A(0)
         MVC   0(40,R5),=40C' ' CLEAR DECIMAL OUTPUT
         MVI   SIGN,C'+'
         LG    R8,0(R4)
         LG    R9,8(R4)        R8-R9 = INT128
         IF    (LTGR,R8,M,R8)
               MVI   SIGN,C'-'
               LCGR  R9,R9
               LCGR  R8,R8
               IILL  R7,1
               ALGR  R9,R7
               ALCGR R8,R8     R8-R9 = ABS NUM
         ENDIF
         DO   WHILE=(LTR,R8,NZ,R8),OR,(LTR,R9,NZ,R9)  LOOP WHILE BITS 
              IF (TMLL,R9,NZ,1)
                 LA   R6,39(R5)
                 BAS  R10,CTD_ADD_POWER
                 ST   R1,AFIRST      ADDR FIRST DIGIT
              ENDIF
              LA   R6,POWER+39
              BAL  R10,CTD_ADD_POWER
              IF   (TMHL,R8,NZ,1)    SHIFT R8:R9 BY 1 BIT
                   SRLG R8,R8,1
                   SRLG R9,R8,1
                   OIHH R9,X'8000'
              ELSE
                   SRLG R8,R8,1
                   SRLG R9,R8,1
              ENDIF
         ENDDO
         IF   (CLI,SIGN,EQ,C'-')
              L    R1,AFIRST
              IF   (LTR,R1,P,R1)
                   BCTR R1,0
                   MVI 0(R1),C'-'
              ELSE
                   LA  R15,12
                   BR  R11
              ENDIF
         ENDIF
         BR   R11
* 
* CFD CALL INTERFACE TO FPCONVRT
*
CFD_CALL EQU *
*
*     SET STRING ADDR, SIZE, AND LENGTH PLUS FLAGS AND BASE
*
         LA    R6,40(R5)
         DO    WHILE=(CLI,0(R5),EQ,C' '),AND,(CLR,R5,LT,R6)
               LA   R5,1(R5)
         ENDDO
         ST    R5,FpconStringAddr
         SR    R6,R5
         STC   R5,FpconStringSize+1
         MVC   FpconStringLen,FpconStringSize
         MVI   FpconFlags,FpconToValue
         MVI   FpconBase,FpconBase10
*
*   CALL FPCONVRT TO CONVERT DECIMAL STRING TO BFP FORMAT
*
         LA    R1,=A(FPCON)
         L     R15,=V(FPCONVRT)
         BALR  R14,R15
         BR    R11
*
* CTD CALL INTERFACE TO FPCONVRT
*
CTD_CALL EQU *
*
*     SET STRING ADDR, SIZE, AND LENGTH PLUS FLAGS AND BASE
*
         ST    R5,FpconStringAddr
         MVI   FpconStringSize+1,40
         MVC   FpconStringLen,FpconStringSize
         MVI   FpconFlags,FpconToValue-FpconToValue  to decimal
         MVI   FpconBase,FpconBase10
*
*   CALL FPCONVRT TO CONVERT DECIMAL STRING TO BFP FORMAT
*
         LA    R1,=A(FPCON)
         L     R15,=V(FPCONVRT)
         BALR  R14,R15
         BR    R11
*********************************************************************
* Level 3 support routines using R10
*********************************************************************
*
* ADD DECIMAL POWER OF 2 TO DECIMAL FIELD WITH AT R6
*
CTD_ADD_POWER EQU *
         LA    R7,POWER+39
         SR    R3,R3                      R3=CARRY IF ANY
         DO    UNTIL=(CLI,0(R7),EQ,C' '),AND,(LTR,R3,Z,R3) 
               IC    R0,0(R6)
               N     R0,=X'0000000F'
               IC    R1,0(R7)
               N     R1,=X'0000000F'
               AR    R0,R1
               AR    R0,R3
               IF    (CH,R0,GT,=H'10')
                     LA   R3,1           CARRY
                     SH   R0,=H'10'
               ELSE
                     LA   R3,0           NO CARRY
               ENDIF
               OILL R0,X'F0'
               STC  R0,0(R6)
               BCTR R6,0
               BCTR R7,0
         ENDDO
         BR    R10
*********************************************************************
* Shared data
*********************************************************************
*
* SHARED DATA
*
         LTORG
         EQUREGS REGS=GPR
         EQUREGS REGS=FPR
TYPE     DC    X'00' CTD/CFD OPERATION TYPE
SIGN     DC    C'+'  SIGN OF DECIMAL NUMBER
PWORK    DC    PL16'0'
POWER    DC    CL40' '
AFIRST   DC    A(0)
TRTTAB_DIGITS DC 256X'00'
         ORG   TRTTAB_DIGITS+C'0'
         DC    10X'FF'
         ORG
TRTTAB_MINUS  DC 256X'00'
         ORG TRTTAB_MINUS+C'-'
         DC  X'FF'
         ORG
TRTTAB_SPACE DC  256X'00'
         ORG TRTTAB_SPACE+C' '
         DC  X'FF'
         ORG   
*
* ASSEMBLE INLINE FPCONVRT INTERFACE BLOCK PASSED VIA R1
*
         FPCONVRT Type=InLine,Archlvl=2
         END         
