.*********************************************************************
.* Copyright 2006 Automated Software Tools Corporation               *
.* This source code is part of z390 assembler/emulator package       *
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.*********************************************************************
.* 04/19/08 RPI 833 ADD STRING QUOTES FOR HLASM COMPATIBILITY 
.*********************************************************************
         MACRO
         CICS_HANDLE
         LCLA  &CONDRNG
         LCLC  &TYPE
         LCLC  &KEYS(60)
         LCLC  &CONDS(200)
&CONDRNG SETA  100                HALF THE COND TABLE
&TYPE    SETC  '&SYSLIST(1)'
         AIF   ('&TYPE' EQ 'AID').AID
         AIF   ('&TYPE' EQ 'CONDITION').COND
         AIF   ('&TYPE' EQ 'ABEND').ABEND
         MNOTE 12,'HANDLE TYPE NOT RECOGNIZED'
         MEXIT
.*
.* HANDLE AID
.*
.AID     ANOP
.* ONLY THE FIRST AID BLOCK IS ACQUIRED HERE
.* PUSH ACQUIRES MORE
         MVC   EIBFN,=X'0206'     SET EIBFN
         USING DFHADBLK,R1
         ICM   R1,15,DFHEIAID     ANY AID BLOCK ADDRESS ?
         BZ    CICS_HANDLE_AID_&SYSNDX._04 EXIT IF NO AID BLOCKS
CICS_HANDLE_AID_&SYSNDX._05 DS 0H
         LR    R14,R1             R14=LAST AID BLOCK ADDRESS
         ICM   R1,15,AIDCHAIN     R1=NEXT AID BLOCK
         BNZ   CICS_HANDLE_AID_&SYSNDX._05 LOOP
.* END OF AID BLOCK CHAIN
         LR    R1,R14             R1=LAST AID BLOCK ADDRESS
         B     CICS_HANDLE_AID_&SYSNDX._01 EXIT
.*
CICS_HANDLE_AID_&SYSNDX._04 DS 0H
.* GET THE FIRST AID BLOCK
         LA    R1,AIDLENG         R1=AID BLOCK LENGTH
         GETMAIN R,LV=(R1)
         XC    0(AIDLENG,R1),0(R1) CLEAR AID BLOCK
         ST    R1,DFHEIAID        SAVE AID BLOCK ADDRESS
         MVC   AIDHEAD,=C'DFHADBLK' SET HEADER
CICS_HANDLE_AID_&SYSNDX._01 DS 0H
.* SET KEY LIST WITH LABEL
&KEYS(01) SETC 'ANYKEY('
&KEYS(02) SETC 'ENTER('
&KEYS(03) SETC 'CLEAR('
&KEYS(04) SETC 'PA1('
&KEYS(05) SETC 'PA2('
&KEYS(06) SETC 'PA3('
&KEYS(07) SETC 'PF1('
&KEYS(08) SETC 'PF2('
&KEYS(09) SETC 'PF3('
&KEYS(10) SETC 'PF4('
&KEYS(11) SETC 'PF5('
&KEYS(12) SETC 'PF6('
&KEYS(13) SETC 'PF7('
&KEYS(14) SETC 'PF8('
&KEYS(15) SETC 'PF9('
&KEYS(16) SETC 'PF10('
&KEYS(17) SETC 'PF11('
&KEYS(18) SETC 'PF12('
&KEYS(19) SETC 'PF13('
&KEYS(20) SETC 'PF14('
&KEYS(21) SETC 'PF15('
&KEYS(22) SETC 'PF16('
&KEYS(23) SETC 'PF17('
&KEYS(24) SETC 'PF18('
&KEYS(25) SETC 'PF19('
&KEYS(26) SETC 'PF20('
&KEYS(27) SETC 'PF21('
&KEYS(28) SETC 'PF22('
&KEYS(29) SETC 'PF23('
&KEYS(30) SETC 'PF24('
.* SET KEYLIST WITHOUT LABEL
&KEYS(31) SETC 'ANYKEY'
&KEYS(32) SETC 'ENTER'
&KEYS(33) SETC 'CLEAR'
&KEYS(34) SETC 'PA1'
&KEYS(35) SETC 'PA2'
&KEYS(36) SETC 'PA3'
&KEYS(37) SETC 'PF1'
&KEYS(38) SETC 'PF2'
&KEYS(39) SETC 'PF3'
&KEYS(40) SETC 'PF4'
&KEYS(41) SETC 'PF5'
&KEYS(42) SETC 'PF6'
&KEYS(43) SETC 'PF7'
&KEYS(44) SETC 'PF8'
&KEYS(45) SETC 'PF9'
&KEYS(46) SETC 'PF10'
&KEYS(47) SETC 'PF11'
&KEYS(48) SETC 'PF12'
&KEYS(49) SETC 'PF13'
&KEYS(50) SETC 'PF14'
&KEYS(51) SETC 'PF15'
&KEYS(52) SETC 'PF16'
&KEYS(53) SETC 'PF17'
&KEYS(54) SETC 'PF18'
&KEYS(55) SETC 'PF19'
&KEYS(56) SETC 'PF20'
&KEYS(57) SETC 'PF21'
&KEYS(58) SETC 'PF22'
&KEYS(59) SETC 'PF23'
&KEYS(60) SETC 'PF24'
.*
&NP      SETA  N'&SYSLIST
&IP      SETA  1
.PLOOPA  ANOP
&IP      SETA  &IP+1
         AIF   (&IP GT &NP).ELOOP
&PARM    SETC  '&SYSLIST(&IP)'
.* INNER LOOP
&INNER   SETA  0
.ILOOPA  ANOP
&INNER   SETA  &INNER+1
         AIF   (&INNER GT 60).BADPARM
&BRACK   SETA  ('&PARM' FIND '(')
         AIF   (&BRACK EQ 0).NOLABA
         AIF   ('&PARM'(1,K'&KEYS(&INNER)) EQ &KEYS(&INNER)).GOTKEY
         AGO   .ILOOPA
.*
.NOLABA  ANOP
         AIF   ('&PARM' EQ '&KEYS(&INNER)').GOTKEY
         AGO   .ILOOPA
.*
.GOTKEY  ANOP
         AIF (&INNER LT 31).LABELSA
.* PARM HAS NO LABEL...IT'S A CANCEL
.* ANYKEY IS A SPECIAL CASE, CLEAR ALL ENTRIES EXCEPT ENTER
         AIF   (&INNER NE 31).NOTANY
         XC    AIDCLEAR(28*4),AIDCLEAR CLEAR ALL ENTRIES EXCEPT ENTER
         AGO   .PLOOPA
.NOTANY  ANOP
         LR    R14,R1             R14=ADDRESS OF AID BLOCK
         LA    R14,12+((&INNER-32)*4)(R14) INDEX TO ENTRY
         XC    0(4,R14),0(R14)    CLEAR ENTRY
         AGO   .PLOOPA
.*
.LABELSA ANOP
.* PARM HAS A LABEL...PROCESS BY TYPE
.* ANYKEY IS A SPECIAL CASE, INSERT LABEL IN ALL ENTRIES EXCEPT ENTER
&KEYLABL SETC  '&PARM'(K'&KEYS(&INNER)+1,K'&PARM-(K'&KEYS(&INNER)+1))
&LABELTQ SETC  T'&KEYLABL
         AIF   ('&KEYLABL'(1,1) EQ '=' OR '&LABELTQ' EQ 'A').LABADLIT
         LA    R0,&KEYLABL        R0=LABEL
         AGO   .LABSTKEY
.LABADLIT ANOP
         L     R0,&KEYLABL        R0=INDIRECT LABEL
.LABSTKEY ANOP
         LR    R14,R1             R14=ADDRESS OF AID BLOCK
         AIF   (&INNER NE 1).NOTANYL
         LA    R14,AIDCLEAR       INDEX TO FIRST ANYKEY
         LA    R15,28             R15=NO. OF ANYKEYS
CICS_HANDLE_AID_&SYSNDX._02 DS 0H
         ST    R0,0(R14)          SET ANYKEY LABEL
         AHI   R14,4              BUMP POINTER
         BCT   R15,CICS_HANDLE_AID_&SYSNDX._02 LOOP
         AGO   .PLOOPA
.NOTANYL ANOP
         LA    R14,12+((&INNER-2)*4)(R14) INDEX TO ENTRY
         ST    R0,0(R14)          SAVE HANDLE AID ADDRESS
         AGO   .PLOOPA
.*
.* HANDLE CONDITION
.*
.COND    ANOP
.* ONLY THE FIRST CONDITION BLOCK IS ACQUIRED HERE
.* PUSH ACQUIRES MORE
         MVC   EIBFN,=X'0204'     SET EIBFN
         USING DFHHCBLK,R1
         ICM   R1,15,DFHEIHCN     ANY CONDITION BLOCK ADDRESS ?
         BZ    CICS_HANDLE_COND_&SYSNDX._04 EXIT IF NO CONDITION BLOCKS
CICS_HANDLE_COND_&SYSNDX._05 DS 0H
         LR    R14,R1             R14=LAST CONDITION BLOCK ADDRESS
         ICM   R1,15,HCNCHAIN     R1=NEXT CONDITION BLOCK
         BNZ   CICS_HANDLE_COND_&SYSNDX._05 LOOP
.* END OF CONDITION BLOCK CHAIN
         LR    R1,R14             R1=LAST CONDITION BLOCK ADDRESS
         B     CICS_HANDLE_COND_&SYSNDX._01 EXIT
.*
CICS_HANDLE_COND_&SYSNDX._04 DS 0H
.* GET THE FIRST CONDITION BLOCK
         LA    R1,HCNLENG         R1=CONDITION BLOCK LENGTH
         GETMAIN R,LV=(R1)
         XC    0(256,R1),0(R1)    CLEAR CONDITION BLOCK
         XC    256(HCNLENG-256,R1),256(R1) CLEAR CONDITION BLOCK
         ST    R1,DFHEIHCN        SAVE CONDITION BLOCK ADDRESS
         MVC   HCNHEAD,=C'DFHHCBLK' SET HEADER
CICS_HANDLE_COND_&SYSNDX._01 DS 0H
.* SET CONDITION LIST WITH LABEL
&CONDS(01) SETC 'ERROR('
&CONDS(12) SETC 'FILENOTFOUND('
&CONDS(13) SETC 'NOTFND('
&CONDS(14) SETC 'DUPREC('
&CONDS(15) SETC 'DUPKEY('
&CONDS(16) SETC 'INVREQ('
&CONDS(18) SETC 'NOSPACE('
&CONDS(19) SETC 'NOTOPEN('
&CONDS(20) SETC 'ENDFILE('
&CONDS(21) SETC 'ILLOGIC('
&CONDS(22) SETC 'LENGERR('
&CONDS(26) SETC 'ITEMERR('
&CONDS(27) SETC 'PGMIDERR('
&CONDS(31) SETC 'EXPIRED('
&CONDS(44) SETC 'QIDERR('
&CONDS(84) SETC 'DISABLED('
.* SET CONDITION LIST WITHOUT LABEL
&IPC     SETA  1
.COLOOP  ANOP
         AIF   ('&CONDS(&IPC)' EQ '').COINCR
&CONDS(&IPC+&CONDRNG) SETC '&CONDS(&IPC)'(1,K'&CONDS(&IPC)-1)
.COINCR  ANOP
&IPC     SETA  &IPC+1
         AIF   (&IPC GT &CONDRNG).CONDDUN
         AGO   .COLOOP
.*
.CONDDUN ANOP
&NP      SETA  N'&SYSLIST
&IP      SETA  1
.PLOOPC  ANOP
&IP      SETA  &IP+1
         AIF   (&IP GT &NP).ELOOP
&PARM    SETC  '&SYSLIST(&IP)'
.* INNER LOOP
&INNER   SETA  0
.ILOOPC  ANOP
&INNER   SETA  &INNER+1
         AIF   (&INNER GT &CONDRNG*2).BADPARM
         AIF   (K'&CONDS(&INNER) EQ 0).ILOOPC
&BRACK   SETA  ('&PARM' FIND '(')
         AIF   (&BRACK EQ 0).NOLABC
         AIF   ('&PARM'(1,K'&CONDS(&INNER)) EQ &CONDS(&INNER)).GOTCOND
         AGO   .ILOOPC
.*
.NOLABC  ANOP
         AIF   ('&PARM' EQ '&CONDS(&INNER)').GOTCOND
         AGO   .ILOOPC
.*
.GOTCOND ANOP
         AIF (&INNER LT &CONDRNG+1).LABELSC
.* PARM HAS NO LABEL...IT'S A CANCEL
         LR    R14,R1             R14=ADDRESS OF CONDITION BLOCK
         LA    R14,12+((&INNER-&CONDRNG)*4)(R14) INDEX TO ENTRY
         XC    0(4,R14),0(R14)    CLEAR ENTRY
         AGO   .PLOOPC
.*
.LABELSC ANOP
.* PARM HAS A LABEL...PROCESS BY TYPE
&HCNLABL SETC '&PARM'(K'&CONDS(&INNER)+1,K'&PARM-(K'&CONDS(&INNER)+1))
&LABELTQ SETC T'&HCNLABL
.*
         AIF   ('&HCNLABL'(1,1) EQ '=' OR '&LABELTQ' EQ 'A').LABHCLIT
         LA    R0,&HCNLABL        R0=LABEL
         AGO   .LABSTHCN
.LABHCLIT ANOP
         L     R0,&HCNLABL        R0=INDIRECT LABEL
.LABSTHCN ANOP
         LR    R14,R1             R14=ADDRESS OF CONDITION BLOCK
         LA    R14,12+(&INNER*4)(R14) INDEX TO ENTRY
         ST    R0,0(R14)          SAVE HANDLE CONDITION ADDRESS
         AGO   .PLOOPC
.*
.* HANDLE ABEND
.*
.ABEND   ANOP
&NP      SETA  N'&SYSLIST
         AIF   (&NP EQ 1 OR &NP GT 2).PARMERR
         MVC   EIBFN,=X'0E0E'     SET EIBFN
.* GET THE ABEND BLOCK IF NONE
         ICM   R1,15,TCTTEABD     ANY ABEND BLOCK ADDRESS ?
         BNZ   CICS_HANDLE_ABEND_&SYSNDX._01 EXIT IF WE HAVE ONE
.* GET THE ABEND BLOCK
         LA    R1,(ABDLENG*25)+8  R1=ABEND BLOCK TOTAL LENGTH
         GETMAIN R,LV=(R1)
         MVC   0(8,R1),=C'DFHABBLK' SET HEADER
         AHI   R1,8               BYPASS EYECATCHER
         ST    R1,TCTTEABD        SAVE ABEND BLOCK ADDRESS
         LR    R14,R1             R14=AREA TO CLEAR
         SR    R15,R15            CLEAR SECOND LENGTH
         LR    R1,R0              R1=LENGTH TO CLEAR
         LR    R0,R14             R0=AREA TO CLEAR
         MVCLE R0,R14,X'00'       CLEAR ABEND BLOCK
         L     R1,TCTTEABD        R1=ABEND BLOCK ADDRESS
CICS_HANDLE_ABEND_&SYSNDX._01 DS 0H
         USING ABDDEST,R1
         LH    R14,TCTTELNK       R14=CURRENT LINK LEVEL
         AHI   R14,-1             -1 FOR INDEX
         MS    R14,=AL4(ABDLENG)  * ENTRY LENGTH
         AR    R1,R14             R1=CORRECT ABEND BLOCK ENTRY
&PARM    SETC  '&SYSLIST(2)'
         AIF   ('&PARM' NE 'CANCEL').TRYRES
.*
.* CANCEL FUNCTION
.*
         MVC   ABDACTIV,=X'FFFF'  SET ENTRY INACTIVE
         DROP  R1
         MEXIT
.*
.TRYRES  ANOP
         AIF   ('&PARM' NE 'RESET').TRYLAB
.*
.* RESET FUNCTION
.*
         XC    ABDACTIV,ABDACTIV  SET ENTRY ACTIVE
         DROP  R1
         MEXIT
.*
.TRYLAB  ANOP
         AIF   ('&PARM'(1,6) NE 'LABEL(').TRYPROG
.*
.* LABEL() FUNCTION
.*
&LABELAB SETC '&PARM'(7,K'&PARM-7)
&LABELTQ SETC T'&LABELAB
.*
         AIF   ('&LABELAB'(1,1) EQ '=' OR '&LABELTQ' EQ 'A').LABABLIT
         LA    R0,&LABELAB        R0=LABEL
         AGO   .LABSTLAB
.LABABLIT ANOP
         L     R0,&LABELAB        R0=INDIRECT LABEL
.LABSTLAB ANOP
         XC    ABDDEST,ABDDEST    CLEAR DESTINATION FIELD
         ST    R0,ABDDEST+4       SAVE LABEL
         XC    ABDACTIV,ABDACTIV  SET ENTRY ACTIVE
         STM   R2,R13,ABDREGS     SAVE OUR REGS
         DROP  R1
         MEXIT
.*
.TRYPROG ANOP
         AIF   ('&PARM'(1,8) NE 'PROGRAM(').BADPARM
&PROGRAM SETC  '&PARM'(9,K'&PARM-9)
         AIF   ('&PROGRAM'(1,1) EQ '''').STRING
         MVC   ABDDEST,&PROGRAM   MOVE PROGRAM AS DESTINATION
         AGO   .NOSTRING
.*
.STRING  ANOP
&PROGLEN SETA  K'&PROGRAM
         AIF   (&PROGLEN LT 3 OR &PROGLEN GT 10).BADPROG
         MVC   ABDDEST,=CL8&PROGRAM MOVE PROGRAM AS DESTINATION
.NOSTRING ANOP
         MVC   ABDCOMM,DFHEICAP   SET ANY COMMAREA ADDRESS
         MVC   ABDCALEN,EIBCALEN  SET ANY COMMAREA LENGTH
         XC    ABDACTIV,ABDACTIV  SET ENTRY ACTIVE
         STM   R2,R13,ABDREGS     SAVE OUR REGS
         DROP  R1
         MEXIT
.*
.BADPARM ANOP
         MNOTE 12,'BAD PARM &PARM'
         MEXIT
.*
.PARMERR ANOP
         MNOTE 12,'PARMS MISSING OR TOO MANY PARMS'
         MEXIT
.*
.BADPROG MNOTE 12,'INVALID PROGRAM'
         MEXIT
.*
.ELOOP   ANOP
         DROP  R1
         MEXIT
         MEND
